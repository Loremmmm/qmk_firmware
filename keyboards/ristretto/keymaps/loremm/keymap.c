/* Copyright 2021 Brandon Lewis
  * 
  * This program is free software: you can redistribute it and/or modify 
  * it under the terms of the GNU General Public License as published by 
  * the Free Software Foundation, either version 2 of the License, or 
  * (at your option) any later version. 
  * 
  * This program is distributed in the hope that it will be useful, 
  * but WITHOUT ANY WARRANTY; without even the implied warranty of 
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
  * GNU General Public License for more details. 
  * 
  * You should have received a copy of the GNU General Public License 
  * along with this program.  If not, see <http://www.gnu.org/licenses/>. 
  */

#include QMK_KEYBOARD_H
#include "raw_hid.h"

#define BASE_LAYER 0
#define NUMTH_LAYER 1
#define SYMBOLS_LAYER 2
#define SETTINGS_LAYER 3
#define ENCODER_LAYER 4

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {

    [BASE_LAYER] = LAYOUT(
        KC_TAB,  KC_Q,    KC_W,    KC_E,  KC_R,  KC_T,                               KC_Y,         KC_U,  KC_I,     KC_O,    KC_P,     KC_BSPC,
        KC_CAPS, KC_A,    KC_S,    KC_D,  KC_F,  KC_G,                               KC_H,         KC_J,  KC_K,    KC_L,    KC_SCLN, KC_QUOT,
        KC_LSFT, KC_Z,    KC_X,    KC_C,  KC_V,  KC_B,                               KC_N,         KC_M,  KC_COMM, KC_DOT,  KC_UP,   KC_SLSH,
        KC_LCTL, KC_LGUI, KC_LALT, TG(1), KC_NO, LT(1,KC_SPC),    LT(4, KC_MUTE),    LT(2,KC_ENT),  KC_NO, TG(3),   KC_LEFT, KC_DOWN, KC_RGHT
    ),

    [NUMTH_LAYER] = LAYOUT(
        KC_GESC, KC_NO,   KC_NO,    KC_NO,   KC_NO, KC_NO,               KC_LCBR, KC_7,  KC_8,   KC_9,   KC_SLSH,  KC_RCBR, 
        KC_TRNS, KC_NO,   KC_NO,    KC_NO,   KC_NO, KC_NO,               KC_LPRN, KC_4,  KC_5,   KC_6,   KC_ASTR,  KC_RPRN,
        KC_TRNS, KC_NO,   KC_NO,    KC_NO,   KC_NO, KC_NO,               KC_LBRC, KC_1,  KC_2,   KC_3,   KC_MINUS, KC_RBRC, 
        KC_TRNS, KC_TRNS, KC_TRNS,  KC_TRNS, KC_NO, KC_NO,     KC_NO,    KC_0,    KC_NO, KC_DOT, KC_EQL, KC_PLUS,  KC_UNDS
    ),

    [SYMBOLS_LAYER] = LAYOUT(
        KC_GESC, KC_EXLM, KC_AT,    KC_HASH, KC_DLR,  KC_PERC,              KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_DEL, 
        KC_TRNS, KC_CIRC, KC_AMPR,  KC_UNDS, KC_BSLS, KC_PIPE,              KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO,
        KC_TRNS, KC_NO,   KC_NO,    KC_NO,   KC_NO,   KC_NO,                KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, 
        KC_TRNS, KC_TRNS, KC_TRNS,  KC_NO,   KC_NO,   KC_NO,     KC_NO,     KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO
    ),

    [SETTINGS_LAYER] = LAYOUT(
        TG(3),   KC_NO,    KC_AT,    KC_HASH, KC_DLR, KC_PERC,                KC_CIRC, KC_AMPR, KC_UNDS, KC_BSLS, KC_PIPE, KC_DEL, 
        CL_SWAP, KC_NO,   KC_NO,    KC_NO,   KC_NO,   KC_NO,                  KC_NO,    KC_NO,    KC_NO,    KC_NO,   KC_NO,    KC_NO,
        KC_NO,   KC_NO,   KC_NO,    KC_NO,   KC_NO,   KC_NO,                  KC_NO,    KC_NO,    KC_NO,    KC_NO,   KC_NO,    KC_NO, 
        CL_NORM, KC_NO,   KC_NO,    KC_NO,   KC_NO,    KC_NO,     RESET,      KC_NO,    KC_NO,    TG(3),    KC_NO,   KC_NO,    KC_NO
    ),

    [ENCODER_LAYER] = LAYOUT(
        KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO,                 KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO,
        KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO,                 KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO,
        KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO,                 KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO,
        KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO,     KC_NO,      KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO
    ),

};

void raw_hid_receive(uint8_t *data, uint8_t length) {
    raw_hid_send(data, length);
}

#ifdef ENCODER_ENABLE
enum encoder_function {
    VOULUME_ENCODER = 0,
    SCROLL_ENCODER,
    UNDO_ENCODER,
    _END
};

static enum encoder_function active_encoder_function = VOULUME_ENCODER;

bool encoder_update_user(uint8_t index, bool clockwise) {
    if (index > 0) {
        return true;
    }

    if (get_highest_layer(layer_state) == ENCODER_LAYER) {
        if (clockwise) {
            if (active_encoder_function - 1 < 0) {
                active_encoder_function = _END - 1;
            } else {
                active_encoder_function -= 1;
            }
        } else {
            if (active_encoder_function + 1 == _END) {
                active_encoder_function = 0;
            } else {
                active_encoder_function += 1;
            }
        }
    } else {
        if (clockwise) {
            switch (active_encoder_function) {
                case _END:
                case VOULUME_ENCODER: tap_code(KC_VOLD); break;
                case SCROLL_ENCODER: tap_code(KC_WH_D); break;
                case UNDO_ENCODER: SEND_STRING(SS_DOWN(X_LCTL) "z" SS_UP(X_LCTL)); break;
            }
        } else {
            switch (active_encoder_function) {
                case _END:
                case VOULUME_ENCODER: tap_code(KC_VOLU); break;
                case SCROLL_ENCODER: tap_code(KC_WH_U); break;
                case UNDO_ENCODER:
                    SEND_STRING(
                        SS_DOWN(X_LCTL)
                        SS_DOWN(X_LSHIFT)
                        "z"
                        SS_UP(X_LSHIFT)
                        SS_UP(X_LCTL)
                    );
                    break;
            }
        }
    }

    return false;
}
#endif

#ifdef OLED_ENABLE
#define FRAME_SIZE 128
#define IDLE_FRAMES 5
#define TYPING_FRAMES 4

static const char PROGMEM idle_frames[][FRAME_SIZE] = {
    {
        // 'pixil-frame-0 (1)', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x10, 0x20, 0x60, 0x80, 0x80, 0x80, 
        0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0xc0, 0x20, 0x90, 0x50, 0x98, 0x24, 0xc2, 0x01, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x01, 0x01, 0x81, 0x82, 0x02, 0x01, 0x00, 0x01, 0x0e, 0x70, 0x80, 0x00, 0x00, 
        0x08, 0x13, 0x1c, 0x10, 0x11, 0x20, 0x20, 0x20, 0x21, 0x40, 0x40, 0x42, 0x44, 0x84, 0x82, 0x84, 
        0x88, 0x08, 0x04, 0x00, 0x00, 0x79, 0x85, 0x12, 0x2a, 0x12, 0x04, 0x18, 0x20, 0x01, 0x1e, 0xe0, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04, 0x08, 0x0c, 0x0b, 
    },

    {
        // 'pixil-frame-1 (1)', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x10, 0x20, 0x60, 0x80, 0x80, 0x80, 
        0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x80, 0x40, 0x20, 0xa0, 0x30, 0x4c, 0x82, 0x01, 0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x00, 0x01, 0x0e, 0x70, 0x80, 0x00, 0x00, 
        0x08, 0x17, 0x18, 0x11, 0x12, 0x21, 0x20, 0x21, 0x22, 0x40, 0x40, 0x44, 0x48, 0x88, 0x84, 0x88, 
        0x90, 0x10, 0x08, 0x00, 0x00, 0xf3, 0x0b, 0x24, 0x54, 0x24, 0x08, 0x30, 0x40, 0x03, 0x3c, 0xc0, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04, 0x08, 0x0c, 0x0b, 
    },

    {
        // 'pixil-frame-2 (1)', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x20, 0x40, 0xc0, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x80, 0x40, 0x60, 0x50, 0x88, 0x04, 0x02, 0xc1, 0xc0, 0x00, 0x00, 0x01, 0x01, 0x01, 
        0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x04, 0x04, 0x02, 0x01, 0x03, 0x0c, 0x70, 0x80, 0x00, 0x00, 
        0x08, 0x17, 0x18, 0x12, 0x15, 0x22, 0x20, 0x23, 0x22, 0x40, 0x40, 0x44, 0x48, 0x88, 0x84, 0x88, 
        0x90, 0x10, 0x08, 0x00, 0x00, 0xe3, 0x13, 0x48, 0xa8, 0x48, 0x10, 0x60, 0x40, 0x03, 0x3c, 0xc0, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04, 0x08, 0x0c, 0x0b, 
    },

    {
        // 'pixil-frame-3 (1)', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0xc0, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x80, 0x40, 0x20, 0xa0, 0x30, 0x48, 0x84, 0x02, 0xc1, 0xc0, 0x00, 0x00, 0x01, 0x01, 0x01, 
        0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x04, 0x04, 0x02, 0x02, 0x02, 0x0c, 0x70, 0x80, 0x00, 0x00, 
        0x08, 0x17, 0x18, 0x11, 0x12, 0x21, 0x20, 0x21, 0x22, 0x40, 0x40, 0x44, 0x48, 0x88, 0x84, 0x88, 
        0x90, 0x10, 0x08, 0x00, 0x00, 0xf3, 0x0b, 0x24, 0x54, 0x24, 0x08, 0x30, 0x40, 0x03, 0x3c, 0xc0, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04, 0x08, 0x0c, 0x0b, 
    },

    {
        // 'pixil-frame-4 (1)', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x20, 0x20, 0x40, 0x80, 0x80, 0x80, 
        0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x80, 0x40, 0x20, 0xa0, 0x30, 0x4c, 0x82, 0x01, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x01, 0x01, 0x81, 0x82, 0x02, 0x01, 0x01, 0x01, 0x0e, 0x70, 0x80, 0x00, 0x00, 
        0x08, 0x17, 0x18, 0x11, 0x12, 0x21, 0x20, 0x21, 0x22, 0x40, 0x40, 0x44, 0x48, 0x88, 0x84, 0x88, 
        0x90, 0x10, 0x08, 0x00, 0x00, 0xf1, 0x09, 0x24, 0x54, 0x24, 0x08, 0x30, 0x40, 0x03, 0x3c, 0xc0, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04, 0x08, 0x0c, 0x0b, 
    }
};

static const char PROGMEM typing_frames[][FRAME_SIZE] = {
    {
        // 'pixil-frame-7 (1)', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x10, 0x20, 0x60, 0x80, 0x80, 0x80, 
        0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x80, 0x60, 0x10, 0x08, 0x04, 0x02, 0x01, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x01, 0x01, 0x81, 0x82, 0x02, 0x01, 0x00, 0x01, 0x0e, 0x70, 0x80, 0x00, 0x00, 
        0x78, 0x8e, 0x01, 0x00, 0x00, 0x80, 0x40, 0x20, 0x20, 0x40, 0x40, 0x42, 0x44, 0x84, 0x82, 0x84, 
        0x88, 0x08, 0x04, 0x00, 0x00, 0x79, 0x85, 0x12, 0x2a, 0x12, 0x04, 0x18, 0x20, 0x01, 0x1e, 0xe0, 
        0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04, 0x08, 0x0c, 0x0b, 
    },

    {
        // 'pixil-frame-0 (1)', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x10, 0x20, 0x60, 0x80, 0x80, 0x80, 
        0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0xc0, 0x20, 0x90, 0x50, 0x98, 0x24, 0xc2, 0x01, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x01, 0x01, 0x81, 0x82, 0x02, 0x01, 0x00, 0x01, 0x0e, 0x70, 0x80, 0x00, 0x00, 
        0x08, 0x13, 0x1c, 0x10, 0x11, 0x20, 0x20, 0x20, 0x21, 0x40, 0x40, 0x42, 0x44, 0x84, 0x82, 0x84, 
        0x88, 0x08, 0x04, 0x00, 0x00, 0x79, 0x85, 0x12, 0x2a, 0x12, 0x04, 0x18, 0x20, 0x01, 0x1e, 0xe0, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04, 0x08, 0x0c, 0x0b, 
    },

    {
        // 'pixil-frame-8 (1)', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x10, 0x20, 0x60, 0x80, 0x80, 0x80, 
        0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0xc0, 0x20, 0x90, 0x50, 0x98, 0x24, 0xc2, 0x01, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x01, 0x01, 0x81, 0x82, 0x02, 0x01, 0x00, 0x01, 0x0e, 0x70, 0x80, 0x00, 0x00, 
        0x08, 0x13, 0x1c, 0x10, 0x11, 0x20, 0x20, 0x20, 0x21, 0x40, 0x40, 0x42, 0x44, 0x84, 0x82, 0x84, 
        0x88, 0x08, 0x04, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1e, 0xe0, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x01, 0x01, 0x19, 0x26, 0x40, 0x40, 0x40, 0x20, 0x20, 0x10, 0x08, 0x08, 0x08, 0x0c, 0x0b
    },

    {
        // 'pixil-frame-0 (1)', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x10, 0x20, 0x60, 0x80, 0x80, 0x80, 
        0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0xc0, 0x20, 0x90, 0x50, 0x98, 0x24, 0xc2, 0x01, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x01, 0x01, 0x81, 0x82, 0x02, 0x01, 0x00, 0x01, 0x0e, 0x70, 0x80, 0x00, 0x00, 
        0x08, 0x13, 0x1c, 0x10, 0x11, 0x20, 0x20, 0x20, 0x21, 0x40, 0x40, 0x42, 0x44, 0x84, 0x82, 0x84, 
        0x88, 0x08, 0x04, 0x00, 0x00, 0x79, 0x85, 0x12, 0x2a, 0x12, 0x04, 0x18, 0x20, 0x01, 0x1e, 0xe0, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04, 0x08, 0x0c, 0x0b, 
    }
};

static uint8_t caps_state = 0;
static uint8_t anim_frame = 0;
static uint8_t max_wpm;
static uint16_t anim_timer;
static uint16_t anim_pause;
static uint16_t typing_timer;

bool led_update_user(led_t led_state) {
    caps_state = led_state.caps_lock;
    return true;
}

void draw_animation(void) {
    if (timer_elapsed(typing_timer) > 300) {
        set_current_wpm(0);
        max_wpm = 0;
    }

    uint8_t wpm = get_current_wpm();
    if (wpm > max_wpm) {
        max_wpm = wpm;
    }

    if (wpm > 0) {
        if (timer_elapsed(anim_timer) >= 300 - max_wpm) {
            anim_timer = timer_read();
            if (anim_frame >= TYPING_FRAMES) {
                anim_frame = 0;
            }
            oled_write_raw_P(typing_frames[anim_frame++], FRAME_SIZE);
        }
    } else {
        if (timer_elapsed(anim_pause) > 300) {
            if (timer_elapsed(anim_timer) >= 100) {
                anim_timer = timer_read();
                if (anim_frame >= IDLE_FRAMES) {
                    anim_frame = 0;
                    anim_pause = timer_read();
                }
                oled_write_raw_P(idle_frames[anim_frame++], FRAME_SIZE);
            }
        }
    }
}

void oled_task_user(void) {
    if (!is_oled_on()) {
        return;
    }

    if (timer_elapsed(typing_timer) >= OLED_TIMEOUT) {
        oled_off();
        return;
    }

    switch (get_highest_layer(layer_state)) {
        case BASE_LAYER:
            oled_write_ln_P(PSTR("HELLO-----"), false);
            #ifdef ENCODER_ENABLE
            oled_write_P(PSTR("ENCDR"), false);
            switch(active_encoder_function) {
                case _END:
                case VOULUME_ENCODER: oled_write_ln_P(PSTR("VOLUM"), false); break;
                case SCROLL_ENCODER: oled_write_ln_P(PSTR("SCROL"), false); break;
                case UNDO_ENCODER: oled_write_ln_P(PSTR("UNDO"), false); break;
            }
            #endif
            if (caps_state) {
                oled_write_ln_P(PSTR("CAPS LOCK"), false);
            } else {
                oled_write_ln_P(PSTR("NO   CAPS"), false);
            }
            oled_write_ln_P(PSTR("\n\n\n"), false);
            break;

        case NUMTH_LAYER:
            oled_write_P(PSTR("NUMTH-----"), false);
            oled_write_ln_P(PSTR(""), false);
            oled_write_P(PSTR("Y = {"), false);
            oled_write_P(PSTR("H = ("), false);
            oled_write_P(PSTR("N = ["), false);
            oled_write_P(PSTR("BS= }"), false);
            oled_write_P(PSTR("' = )"), false);
            oled_write_P(PSTR("/ = ]"), false);
            oled_write_ln_P(PSTR("\n"), false);
            break;

        case SYMBOLS_LAYER:
            oled_write_P(PSTR("SYMBL-----"), false);
            oled_write_ln_P(PSTR(""), false);
            oled_write_P(PSTR("Q = !"), false);
            oled_write_P(PSTR("W = @"), false);
            oled_write_P(PSTR("E = #"), false);
            oled_write_P(PSTR("R = $"), false);
            oled_write_P(PSTR("T = \%"), false);
            oled_write_P(PSTR("A = ^"), false);
            oled_write_P(PSTR("S = &"), false);
            oled_write_P(PSTR("D = _"), false);
            // oled_write_P(PSTR("F = \\"), false);
            // oled_write_P(PSTR("G = |"), false);
            // oled_write_ln_P(PSTR("\n\n"), false);
            break;

        case SETTINGS_LAYER:
            keymap_config.raw = eeconfig_read_keymap();
            oled_write_ln_P(PSTR("STTNG-----"), false);
            oled_write_ln_P(PSTR("CAPS"), false);
            if (keymap_config.swap_control_capslock == true) {
                oled_write_ln_P(PSTR("SWAP\n"), false);
            } else {
                oled_write_ln_P(PSTR("NRML\n"), false);
            }
            oled_write_ln_P(PSTR("\n\n"), false);
            break;

        #ifdef ENCODER_ENABLE
        case ENCODER_LAYER:
            oled_write_ln_P(PSTR("ENCDR-----"), false);            
            if (active_encoder_function == VOULUME_ENCODER) {
                oled_write_P(PSTR(">VOLM"), false);
            } else {
                oled_write_P(PSTR(" VOLM"), false);
            }
            if (active_encoder_function == SCROLL_ENCODER) {
                oled_write_P(PSTR(">SCRL"), false);
            } else {
                oled_write_P(PSTR(" SCRL"), false);
            }
            if (active_encoder_function == UNDO_ENCODER) {
                oled_write_P(PSTR(">UNDO"), false);
            } else {
                oled_write_P(PSTR(" UNDO"), false);
            }
            oled_write_ln_P(PSTR("\n\n"), false);
            break;
        #endif
    }
    
    oled_set_cursor(0, 12);
    draw_animation();
}

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    typing_timer = timer_read();
    return true;
}
#endif

